// Generated from AST/LabCommParser.all
package AST;
import java.util.ArrayList;
import beaver.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "LabCommParser.beaver".
 */
public class LabCommParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short SAMPLE = 1;
		static public final short VOID = 2;
		static public final short IDENTIFIER = 3;
		static public final short SEMICOLON = 4;
		static public final short TYPEDEF = 5;
		static public final short STRUCT = 6;
		static public final short LBRACE = 7;
		static public final short RBRACE = 8;
		static public final short LBRACK = 9;
		static public final short RBRACK = 10;
		static public final short BOOLEAN = 11;
		static public final short BYTE = 12;
		static public final short SHORT = 13;
		static public final short INT = 14;
		static public final short LONG = 15;
		static public final short FLOAT = 16;
		static public final short DOUBLE = 17;
		static public final short STRING = 18;
		static public final short COMMA = 19;
		static public final short INTEGER_LITERAL = 20;
		static public final short UNDERSCORE = 21;

		static public final String[] NAMES = {
			"EOF",
			"SAMPLE",
			"VOID",
			"IDENTIFIER",
			"SEMICOLON",
			"TYPEDEF",
			"STRUCT",
			"LBRACE",
			"RBRACE",
			"LBRACK",
			"RBRACK",
			"BOOLEAN",
			"BYTE",
			"SHORT",
			"INT",
			"LONG",
			"FLOAT",
			"DOUBLE",
			"STRING",
			"COMMA",
			"INTEGER_LITERAL",
			"UNDERSCORE"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9oTaybFL44Gnh#tpC00moBmsCSP1bH0G17XGBXmuIW91mz6BWH2NDWqqOk9VoYRA8iRYg2" +
		"oMdpTr607Hapebr#gggkwkgkx7e0to8YW4yqemGt4KOWwrAC1ZMX22jUHnZraS0sLZ2X0X1" +
		"hKNeZ8e4A#qz$rBx$yiJkOB77vTi5$KzVr8O7R2163ZoHQPE7C4w0QhTPJZ29KeGnjZAX6A" +
		"Jeexw0TvTPEeaUsv2lkoXSavRDyae#oAHkoBcieaG#uXMvaMMalWFlC2dYiEMBLCLh5z2IP" +
		"iupPAdXQdtDLp1e$g#fyHC0AWalzfpkOBFbsoArhP6rDUfS9tbIBuudK4$BEKgm#P4J4Aem" +
		"qSvNMDdh0hu4ahFRtYrIQzmlusY5FrVyMTdYan#WvE5B4n0ofFPhpYV0bWH6TpxZhdFLfUx" +
		"l019aaK#G9UKgUaUTacioGMJ97kfZxMDVFanVaeTgFdDobv2LvhFQuobVazRbpj94#TywSN" +
		"ts3QcyvyGEE7kQhxIfmj4FlsvaRLZdcrgRoWLjRddpzfqAEv50ELFz9TcNLwk$8iYp9egp8" +
		"UrmwP4$bR$9BzjNQ8J#ijYt755bs98Z7$ZJux4lFqcpnsQC12TcfXfZjrxJA6iRagFqFTQJ" +
		"UzhL7VDkxMUfP#wzvbjOJfPQQZW==");
 // Generated from AST/LabCommParser.all
public static class SourceError extends Error {
    public SourceError(String msg) {
      super(msg);
    }
  }
  class Events extends Parser.Events {
    public void syntaxError(Symbol token) {
      StringBuffer s = new StringBuffer();
      s.append(token.getLine(token.getStart()) + ", " + token.getColumn(token.getStart()) + "\n");
      s.append("  *** Syntactic error: unexpected token " + Terminals.NAMES[token.getId()]);
      throw new SourceError(s.toString());
        //super.syntaxError(token);
        //throw new RuntimeException(token.getLine(token.getStart()) + ", " + 
	// token.getColumn(token.getStart()) + ": Syntax Error");
    }
    public void scannerError(Scanner.Exception e) {
      StringBuffer s = new StringBuffer();
      s.append(e.line + ", " + e.column + "\n");
      s.append("  *** Lexical error: " + e.getMessage());
      throw new SourceError(s.toString());
        //super.scannerError(e);
        //throw new RuntimeException("Unexpected token");
    }

  }

        {
            report = new Events(); // Use error handler in parser
        }

	public LabCommParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 0: // goal = 
			{
					 return new Program();
			}
			case 1: // goal = decl_list.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					 return new Program(l);
			}
			case 2: // decl_list = decl.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final Decl d = (Decl) _symbol_d.value;
					 return new List().add(d);
			}
			case 3: // decl_list = decl_list.l decl.d
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_d = _symbols[offset + 2];
					final Decl d = (Decl) _symbol_d.value;
					 return l.add(d);
			}
			case 4: // decl = type_decl.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final TypeDecl t = (TypeDecl) _symbol_t.value;
					 return t;
			}
			case 5: // decl = sample_decl.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final SampleDecl s = (SampleDecl) _symbol_s.value;
					 return s;
			}
			case 6: // var_decl_list = var_decl.v
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final Field v = (Field) _symbol_v.value;
					 return new List().add(v);
			}
			case 7: // var_decl_list = var_decl_list.l var_decl.v
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_v = _symbols[offset + 2];
					final Field v = (Field) _symbol_v.value;
					 return l.add(v);
			}
			case 8: // var_decl = type.t IDENTIFIER.IDENTIFIER SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new Field(t, ((String)IDENTIFIER.value));
			}
			case 9: // var_decl = type.t IDENTIFIER.IDENTIFIER dim_list.d SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 2];
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					final Symbol SEMICOLON = _symbols[offset + 4];
					 return new Field(new ParseArrayType(t, d), ((String)IDENTIFIER.value));
			}
			case 10: // type_decl = TYPEDEF.TYPEDEF type.t IDENTIFIER.IDENTIFIER SEMICOLON.SEMICOLON
			{
					final Symbol TYPEDEF = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Type t = (Type) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol SEMICOLON = _symbols[offset + 4];
					 return new TypeDecl(t, ((String)IDENTIFIER.value));
			}
			case 11: // type_decl = TYPEDEF.TYPEDEF type.t IDENTIFIER.IDENTIFIER dim_list.d SEMICOLON.SEMICOLON
			{
					final Symbol TYPEDEF = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Type t = (Type) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_d = _symbols[offset + 4];
					final List d = (List) _symbol_d.value;
					final Symbol SEMICOLON = _symbols[offset + 5];
					 return new TypeDecl(new ParseArrayType(t, d), ((String)IDENTIFIER.value));
			}
			case 12: // sample_decl = SAMPLE.SAMPLE type.t IDENTIFIER.IDENTIFIER SEMICOLON.SEMICOLON
			{
					final Symbol SAMPLE = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Type t = (Type) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol SEMICOLON = _symbols[offset + 4];
					 return new SampleDecl(t, ((String)IDENTIFIER.value));
			}
			case 13: // sample_decl = SAMPLE.SAMPLE type.t IDENTIFIER.IDENTIFIER dim_list.d SEMICOLON.SEMICOLON
			{
					final Symbol SAMPLE = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Type t = (Type) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol _symbol_d = _symbols[offset + 4];
					final List d = (List) _symbol_d.value;
					final Symbol SEMICOLON = _symbols[offset + 5];
					 return new SampleDecl(new ParseArrayType(t, d), ((String)IDENTIFIER.value));
			}
			case 14: // sample_decl = SAMPLE.SAMPLE VOID.VOID IDENTIFIER.IDENTIFIER SEMICOLON.SEMICOLON
			{
					final Symbol SAMPLE = _symbols[offset + 1];
					final Symbol VOID = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol SEMICOLON = _symbols[offset + 4];
					 return new SampleDecl(new VoidType(), ((String)IDENTIFIER.value));
			}
			case 15: // type = prim_type.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final PrimType p = (PrimType) _symbol_p.value;
					 return p;
			}
			case 16: // type = user_type.u
			{
					final Symbol _symbol_u = _symbols[offset + 1];
					final UserType u = (UserType) _symbol_u.value;
					 return u;
			}
			case 17: // type = struct_type.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final StructType s = (StructType) _symbol_s.value;
					 return s;
			}
			case 18: // prim_type = BOOLEAN.BOOLEAN
			{
					final Symbol BOOLEAN = _symbols[offset + 1];
					 return new PrimType(((String)BOOLEAN.value), ASTNode.LABCOMM_BOOLEAN);
			}
			case 19: // prim_type = BYTE.BYTE
			{
					final Symbol BYTE = _symbols[offset + 1];
					 return new PrimType(((String)BYTE.value), ASTNode.LABCOMM_BYTE);
			}
			case 20: // prim_type = SHORT.SHORT
			{
					final Symbol SHORT = _symbols[offset + 1];
					 return new PrimType(((String)SHORT.value), ASTNode.LABCOMM_SHORT);
			}
			case 21: // prim_type = INT.INT
			{
					final Symbol INT = _symbols[offset + 1];
					 return new PrimType(((String)INT.value), ASTNode.LABCOMM_INT);
			}
			case 22: // prim_type = LONG.LONG
			{
					final Symbol LONG = _symbols[offset + 1];
					 return new PrimType(((String)LONG.value), ASTNode.LABCOMM_LONG);
			}
			case 23: // prim_type = FLOAT.FLOAT
			{
					final Symbol FLOAT = _symbols[offset + 1];
					 return new PrimType(((String)FLOAT.value), ASTNode.LABCOMM_FLOAT);
			}
			case 24: // prim_type = DOUBLE.DOUBLE
			{
					final Symbol DOUBLE = _symbols[offset + 1];
					 return new PrimType(((String)DOUBLE.value), ASTNode.LABCOMM_DOUBLE);
			}
			case 25: // prim_type = STRING.STRING
			{
					final Symbol STRING = _symbols[offset + 1];
					 return new PrimType(((String)STRING.value), ASTNode.LABCOMM_STRING);
			}
			case 26: // user_type = IDENTIFIER.IDENTIFIER
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					 return new UserType(((String)IDENTIFIER.value));
			}
			case 27: // struct_type = STRUCT.STRUCT LBRACE.LBRACE var_decl_list.l RBRACE.RBRACE
			{
					final Symbol STRUCT = _symbols[offset + 1];
					final Symbol LBRACE = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol RBRACE = _symbols[offset + 4];
					 return new StructType(l);
			}
			case 28: // dim_list = dim.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final Dim d = (Dim) _symbol_d.value;
					 return new List().add(d);
			}
			case 29: // dim_list = dim_list.l dim.d
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_d = _symbols[offset + 2];
					final Dim d = (Dim) _symbol_d.value;
					 return l.add(d);
			}
			case 30: // dim = LBRACK.LBRACK exp_list.e RBRACK.RBRACK
			{
					final Symbol LBRACK = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final List e = (List) _symbol_e.value;
					final Symbol RBRACK = _symbols[offset + 3];
					 return new Dim(e);
			}
			case 31: // exp_list = exp.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Exp e = (Exp) _symbol_e.value;
					 return new List().add(e);
			}
			case 32: // exp_list = exp_list.l COMMA.COMMA exp.e
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Exp e = (Exp) _symbol_e.value;
					 return l.add(e);
			}
			case 33: // exp = INTEGER_LITERAL.INTEGER_LITERAL
			{
					final Symbol INTEGER_LITERAL = _symbols[offset + 1];
					 return new IntegerLiteral(((String)INTEGER_LITERAL.value));
			}
			case 34: // exp = UNDERSCORE.UNDERSCORE
			{
					final Symbol UNDERSCORE = _symbols[offset + 1];
					 return new VariableSize();
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
